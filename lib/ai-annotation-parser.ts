import type { AIAnnotationRawData, AIAnnotationError } from './pdf-types'

/**
 * AIæ‰¹æ³¨å“åº”è§£æå™¨
 * 
 * ç”¨äºè§£æAIæœåŠ¡è¿”å›çš„æ‰¹æ³¨å†…å®¹ï¼Œæ”¯æŒè‡ªå®šä¹‰æ ¼å¼çš„åˆ†éš”ç¬¦è§£æ
 * é‡‡ç”¨çº¯å‡½æ•°è®¾è®¡ï¼Œä¾¿äºæµ‹è¯•å’Œç»´æŠ¤
 */

/**
 * è§£æAI APIè¿”å›çš„æ‰¹æ³¨å“åº”
 * @param apiResponse - AI APIè¿”å›çš„æ–‡æœ¬å†…å®¹
 * @returns è§£æåçš„æ‰¹æ³¨æ•°ç»„
 */
export function parseAIAnnotationResponse(apiResponse: string): AIAnnotationRawData[] {
  if (!apiResponse || typeof apiResponse !== 'string') {
    console.warn("AIå“åº”ä¸ºç©ºæˆ–æ ¼å¼æ— æ•ˆ")
    return []
  }

  try {
    // ä½¿ç”¨---ANNOTATION---åˆ†éš”ç¬¦åˆ†å‰²æ‰¹æ³¨å—
    const annotationBlocks = apiResponse
      .split("---ANNOTATION---")
      .filter(block => block.trim())
      .slice(1) // ç§»é™¤ç¬¬ä¸€ä¸ªç©ºå—

    console.log(`ğŸ” è§£æAIå“åº”: æ‰¾åˆ° ${annotationBlocks.length} ä¸ªæ‰¹æ³¨å—`)

    const parsedAnnotations: AIAnnotationRawData[] = []

    annotationBlocks.forEach((block, index) => {
      try {
        const annotation = parseAnnotationBlock(block, index)
        if (annotation && validateAnnotation(annotation)) {
          parsedAnnotations.push(annotation)
        } else {
          console.warn(`âš ï¸ æ‰¹æ³¨å— ${index + 1} è§£æå¤±è´¥æˆ–éªŒè¯å¤±è´¥`)
        }
      } catch (error) {
        console.error(`âŒ è§£ææ‰¹æ³¨å— ${index + 1} æ—¶å‘ç”Ÿé”™è¯¯:`, error)
      }
    })

    console.log(`âœ… æˆåŠŸè§£æ ${parsedAnnotations.length} æ¡æœ‰æ•ˆæ‰¹æ³¨`)
    return parsedAnnotations

  } catch (error) {
    console.error("è§£æAIæ‰¹æ³¨å“åº”æ—¶å‘ç”Ÿé”™è¯¯:", error)
    return []
  }
}

/**
 * è§£æå•ä¸ªæ‰¹æ³¨å—
 * @param block - æ‰¹æ³¨å—æ–‡æœ¬
 * @param index - æ‰¹æ³¨ç´¢å¼•
 * @returns è§£æåçš„æ‰¹æ³¨æ•°æ®
 */
function parseAnnotationBlock(block: string, index: number): AIAnnotationRawData | null {
  const lines = block.trim().split('\n')
  const annotation: Partial<AIAnnotationRawData> = {}

  // è§£ææ¯ä¸€è¡Œçš„é”®å€¼å¯¹
  lines.forEach(line => {
    const colonIndex = line.indexOf(':')
    if (colonIndex === -1) return

    const key = line.substring(0, colonIndex).trim().toUpperCase()
    const value = line.substring(colonIndex + 1).trim()

    if (!value) return

    switch (key) {
      case 'TYPE':
        annotation.type = value
        break
      case 'SEVERITY':
        annotation.severity = value
        break
      case 'PAGE':
        annotation.page = parsePageNumber(value)
        break
      case 'TITLE':
        annotation.title = value
        break
      case 'DESCRIPTION':
        annotation.description = value
        break
      case 'SUGGESTION':
        annotation.suggestion = value
        break
      case 'SELECTED':
        annotation.selected = value
        break
    }
  })

  // ç”Ÿæˆå”¯ä¸€ID
  if (annotation.title && annotation.description) {
    return {
      id: `auto-${Date.now()}-${index}`,
      type: annotation.type || 'content',
      severity: annotation.severity || 'medium',
      page: annotation.page,
      title: annotation.title,
      description: annotation.description,
      suggestion: annotation.suggestion || '',
      selected: annotation.selected || 'æ— ç‰¹å®šä½ç½®',
      isAutoGenerated: true
    }
  }

  return null
}

/**
 * è§£æé¡µç æ•°å­—
 * @param pageValue - é¡µç å­—ç¬¦ä¸²
 * @returns é¡µç æ•°å­—
 */
function parsePageNumber(pageValue: string): number | undefined {
  const pageNum = parseInt(pageValue)
  return isNaN(pageNum) ? undefined : Math.max(1, pageNum)
}

/**
 * éªŒè¯æ‰¹æ³¨æ•°æ®çš„å®Œæ•´æ€§
 * @param annotation - æ‰¹æ³¨æ•°æ®
 * @returns æ˜¯å¦æœ‰æ•ˆ
 */
function validateAnnotation(annotation: AIAnnotationRawData): boolean {
  const requiredFields = ['id', 'title', 'description', 'type', 'severity', 'selected']
  
  for (const field of requiredFields) {
    if (!annotation[field as keyof AIAnnotationRawData]) {
      console.warn(`âŒ æ‰¹æ³¨ç¼ºå°‘å¿…éœ€å­—æ®µ: ${field}`)
      return false
    }
  }

  // éªŒè¯å­—æ®µé•¿åº¦
  if (annotation.title.length > 200) {
    console.warn("âŒ æ‰¹æ³¨æ ‡é¢˜è¿‡é•¿")
    return false
  }

  if (annotation.description.length > 2000) {
    console.warn("âŒ æ‰¹æ³¨æè¿°è¿‡é•¿")
    return false
  }

  return true
}

/**
 * åˆ›å»ºè§£æé”™è¯¯å¯¹è±¡
 * @param message - é”™è¯¯æ¶ˆæ¯
 * @param details - é”™è¯¯è¯¦æƒ…
 * @returns è§£æé”™è¯¯å¯¹è±¡
 */
export function createParseError(message: string, details?: any): AIAnnotationError {
  return {
    code: 'PARSE_ERROR',
    message,
    details
  }
}

/**
 * è·å–è§£æç»Ÿè®¡ä¿¡æ¯
 * @param originalResponse - åŸå§‹å“åº”
 * @param parsedAnnotations - è§£æåçš„æ‰¹æ³¨
 * @returns ç»Ÿè®¡ä¿¡æ¯
 */
export function getParseStatistics(originalResponse: string, parsedAnnotations: AIAnnotationRawData[]) {
  const blocks = originalResponse.split("---ANNOTATION---").filter(block => block.trim()).length - 1
  
  return {
    totalBlocks: blocks,
    successfulParse: parsedAnnotations.length,
    successRate: blocks > 0 ? Math.round((parsedAnnotations.length / blocks) * 100) : 0,
    avgTitleLength: parsedAnnotations.length > 0 
      ? Math.round(parsedAnnotations.reduce((sum, ann) => sum + ann.title.length, 0) / parsedAnnotations.length)
      : 0,
    avgDescriptionLength: parsedAnnotations.length > 0
      ? Math.round(parsedAnnotations.reduce((sum, ann) => sum + ann.description.length, 0) / parsedAnnotations.length)
      : 0
  }
}
