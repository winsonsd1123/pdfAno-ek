import type { AIAnnotationRawData, AIAnnotationError } from './pdf-types'

/**
 * AI批注响应解析器
 * 
 * 用于解析AI服务返回的批注内容，支持自定义格式的分隔符解析
 * 采用纯函数设计，便于测试和维护
 */

/**
 * 解析AI API返回的批注响应
 * @param apiResponse - AI API返回的文本内容
 * @returns 解析后的批注数组
 */
export function parseAIAnnotationResponse(apiResponse: string): AIAnnotationRawData[] {
  if (!apiResponse || typeof apiResponse !== 'string') {
    console.warn("AI响应为空或格式无效")
    return []
  }

  try {
    // 使用---ANNOTATION---分隔符分割批注块
    const annotationBlocks = apiResponse
      .split("---ANNOTATION---")
      .filter(block => block.trim())
      .slice(1) // 移除第一个空块

    console.log(`🔍 解析AI响应: 找到 ${annotationBlocks.length} 个批注块`)

    const parsedAnnotations: AIAnnotationRawData[] = []

    annotationBlocks.forEach((block, index) => {
      try {
        const annotation = parseAnnotationBlock(block, index)
        if (annotation && validateAnnotation(annotation)) {
          parsedAnnotations.push(annotation)
        } else {
          console.warn(`⚠️ 批注块 ${index + 1} 解析失败或验证失败`)
        }
      } catch (error) {
        console.error(`❌ 解析批注块 ${index + 1} 时发生错误:`, error)
      }
    })

    console.log(`✅ 成功解析 ${parsedAnnotations.length} 条有效批注`)
    return parsedAnnotations

  } catch (error) {
    console.error("解析AI批注响应时发生错误:", error)
    return []
  }
}

/**
 * 解析单个批注块
 * @param block - 批注块文本
 * @param index - 批注索引
 * @returns 解析后的批注数据
 */
function parseAnnotationBlock(block: string, index: number): AIAnnotationRawData | null {
  const lines = block.trim().split('\n')
  const annotation: Partial<AIAnnotationRawData> = {}

  // 解析每一行的键值对
  lines.forEach(line => {
    const colonIndex = line.indexOf(':')
    if (colonIndex === -1) return

    const key = line.substring(0, colonIndex).trim().toUpperCase()
    const value = line.substring(colonIndex + 1).trim()

    if (!value) return

    switch (key) {
      case 'TYPE':
        annotation.type = value
        break
      case 'SEVERITY':
        annotation.severity = value
        break
      case 'PAGE':
        annotation.page = parsePageNumber(value)
        break
      case 'TITLE':
        annotation.title = value
        break
      case 'DESCRIPTION':
        annotation.description = value
        break
      case 'SUGGESTION':
        annotation.suggestion = value
        break
      case 'SELECTED':
        annotation.selected = value
        break
    }
  })

  // 生成唯一ID
  if (annotation.title && annotation.description) {
    return {
      id: `auto-${Date.now()}-${index}`,
      type: annotation.type || 'content',
      severity: annotation.severity || 'medium',
      page: annotation.page,
      title: annotation.title,
      description: annotation.description,
      suggestion: annotation.suggestion || '',
      selected: annotation.selected || '无特定位置',
      isAutoGenerated: true
    }
  }

  return null
}

/**
 * 解析页码数字
 * @param pageValue - 页码字符串
 * @returns 页码数字
 */
function parsePageNumber(pageValue: string): number | undefined {
  const pageNum = parseInt(pageValue)
  return isNaN(pageNum) ? undefined : Math.max(1, pageNum)
}

/**
 * 验证批注数据的完整性
 * @param annotation - 批注数据
 * @returns 是否有效
 */
function validateAnnotation(annotation: AIAnnotationRawData): boolean {
  const requiredFields = ['id', 'title', 'description', 'type', 'severity', 'selected']
  
  for (const field of requiredFields) {
    if (!annotation[field as keyof AIAnnotationRawData]) {
      console.warn(`❌ 批注缺少必需字段: ${field}`)
      return false
    }
  }

  // 验证字段长度
  if (annotation.title.length > 200) {
    console.warn("❌ 批注标题过长")
    return false
  }

  if (annotation.description.length > 2000) {
    console.warn("❌ 批注描述过长")
    return false
  }

  return true
}

/**
 * 创建解析错误对象
 * @param message - 错误消息
 * @param details - 错误详情
 * @returns 解析错误对象
 */
export function createParseError(message: string, details?: any): AIAnnotationError {
  return {
    code: 'PARSE_ERROR',
    message,
    details
  }
}

/**
 * 获取解析统计信息
 * @param originalResponse - 原始响应
 * @param parsedAnnotations - 解析后的批注
 * @returns 统计信息
 */
export function getParseStatistics(originalResponse: string, parsedAnnotations: AIAnnotationRawData[]) {
  const blocks = originalResponse.split("---ANNOTATION---").filter(block => block.trim()).length - 1
  
  return {
    totalBlocks: blocks,
    successfulParse: parsedAnnotations.length,
    successRate: blocks > 0 ? Math.round((parsedAnnotations.length / blocks) * 100) : 0,
    avgTitleLength: parsedAnnotations.length > 0 
      ? Math.round(parsedAnnotations.reduce((sum, ann) => sum + ann.title.length, 0) / parsedAnnotations.length)
      : 0,
    avgDescriptionLength: parsedAnnotations.length > 0
      ? Math.round(parsedAnnotations.reduce((sum, ann) => sum + ann.description.length, 0) / parsedAnnotations.length)
      : 0
  }
}
